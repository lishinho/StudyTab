1223
1.分页/cookie->不传的话，就是变量对应类的默认初始值，builder模式就是适用于有非常多的变量，但是每一个变量又都不是必填的情况
2.客户端怎么改->就那么改 改成null就行其他不管
3.if语句的异常
private void checkElementIndex(int index) {
        if (!isElementIndex(index))
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

builder模式

user类中构造函数来传参数代码可读性很差，调用者很艰难

gettersetter方法 对象可能产生不一致状态，不可变类好处很差

Builder模式使用了链式调用。可读性更佳。
Builder的内部类构造方法中只接收必传的参数，并且该必传的参数适用了final修饰符
Builder模式拥有其所有的优点，而没有上述方法中的缺点。客户端的代码更容易写，并且更重要的是，可读性非常好。唯一可能存在的问题就是会产生多余的Builder对象，消耗内存。然而大多数情况下我们的Builder内部类使用的是静态修饰的(static)，所以这个问题也没多大关系。
由于Builder是非线程安全的，所以如果要在Builder内部类中检查一个参数的合法性，必需要在对象创建完成之后再检查。
public User build() {
  User user = new user(this);
  if (user.getAge() > 120) {
    throw new IllegalStateException(“Age out of range”); // 线程安全
  }
  return user;
}



要好好看之前写的代码
不需要的逻辑不要加

.context.annotation.ConflictingBeanDefinitionException: Annotation-specified bean name 'resourceServiceController' for bean class 
Annotation-specified bean name 'resourceServiceController' for bean class [io.transwarp.guardian.server.boot.controller.ResourceServiceController] conflicts with existing, non-compatible bean definition of same name and class [io.transwarp.guardian.server.boot.controller.v2.ResourceServiceController]

mvn install -DskipTests -Pcopy-deps


du -h --max-depth=1 定位最大文件
cd /var/log 看日志
ls -al
rm messages-201911* -rf

ls –lhS 将文件以从大到小顺序展现

inceptor-server-inceptor1-697b7f4665-zpwzs           0/1       Error                  1          43s       172.16.1.237   tw-node1237

如何删除不需要的分支：  gitlab-repo-branches
setterm -inversescreen on 终端变白
ps 命令虽然在收集运行在系统上的进程信息时非常有用,但也有不足之处:它只能显示某个特定时间点的信息。如果想观察那些频繁换进换出的内存的进程趋势,用 ps 命令就不方便了。
而 top 命令刚好适用这种情况。 top 命令跟 ps 命令相似,能够显示进程信息,但它是实时显示的。

