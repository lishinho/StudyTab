=========
JAVA基础
=========
### 重载equals方法为什么要重载hashcode
你的类将违反 hashCode 的一般约定，这将阻止该类在 HashMap 和 HashSet 等集合中正常运行。
hashmap中使用
Hash的公式---> index = HashCode（Key） & （Length - 1）
找到key对应的index，然后遍历链表equals找到key对应的value
如果根据 equals(Object) 方法判断出两个对象是相等的，那么在两个对象上调用 hashCode 必须产生相同的整数结果。

###自动装拆箱
Integer i = 10 //拆箱
int n = i; // 装箱
在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。
注意拆箱时的integer.cache会缓存-128~127的值













=========
集合框架
=========

### HashMap 
- 底层数据结构组成 数组加链表 k-v数据结构叫entry/node

- /put过程/get过程
输入 计算哈希后的index equals方法找entry key

- 哈希碰撞 为什么需要链表

- 头插尾插(jdk7前线程安全问题/jdk8后线程安全问题）

- 初始容量 扩容机制 当前长度/扩容因子 扩容/rehash
 
 初始值为什么是16 -- 利于rehash位运算
 equals和hashcode

 一致性哈希 -- 容错性/扩展性/虚拟节点

### ConcurrentHashMap

- 如何解决？有没有线程安全的并发容器？
collections.synchronizedMap
hashtable

- ConcurrentHashMap 是如何实现的？

segment (reentrantlock)+hashEntry volatile
node+CAS+红黑树+synchronized

- 谈谈你理解的 Hashtable，讲讲其中的 get put 过程。ConcurrentHashMap同问。
定位segment put

写入过程
定位访问segment 自旋获取锁 遍历hashentry equals方法 尾插法插入 

### ArrayList

ArrayList系列
- ArrayList, LinkerList, Vector
查询效率高，增删效率低，线程不安全。使用频率很高。
arraylist扩容

- 快速失败（fail—fast）是啥，应用场景有哪些？安全失败（fail—safe）同问。
iterator在迭代器遍历元素的过程中，如果集合的结构被改变的话，就会抛出异常，防止继续遍历。（hashmap/hashtable）














============
JAVA并发
============

### 锁

- synchronized底层原理是啥？
java对象头 monitor mutex

- synchronized锁升级策略
偏向锁-自旋轻量级锁-重量级锁
JVM 使用了锁升级的优化方式，就是先使用偏向锁优先同一线程然后再次获取锁，如果失败，就升级为 CAS 轻量级锁，如果失败就会短暂自旋，防止线程被系统挂起。最后如果以上都失败就升级为重量级锁。

- threadlocal

threadlocal数据隔离 数据结构模型 弱引用 哈希冲突解决 内存泄漏
没有链表的hashmap
- 软引用的key会导致内存泄漏

- volatile

volatile jmm 缓存一致性 内存可见性 内存屏障防止指令重排 单例模式双重检验锁


- 线程池
**用途** 降低资源消耗  提升系统相应速度 易于管理
**流程** 
核心线程池是否已满 - 阻塞队列是否已满 - 线程池是否已满
-- 新建线程 - 队列等待（队列满了会新建线程）核心线程数外的线程会按keepalivetime 策略 - 异常处理策略

**线程池的创建** ThreadPoolExecutor类 executors的几个参数 如何设置线程池大小 1线程池中核心线程数 2最大 3用于缓存任务的阻塞队列 4空闲线程的存活时间/5单位 6线程工厂 7拒绝策略处理
**合理配置** 
    任务的性质：CPU 密集型任务，IO 密集型任务和混合型任务
CPU 密集型任务 - 尽可能少的线程数量，如配置Ncpu+1个线程的线程池。
IO 密集型任务 - 尽可能多的线程，如2xNcpu。
混合型的任务，如果可以拆分，则将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务

Worker是通过继承AQS，使用AQS来实现独占锁这个功能。

- forkjoin -mapreduce -分治法/工作窃取算法 WorkStealingPool
// forkJoinPool is a special thread pool which the numbers of thread depends on CPU cores
// each thread in the pool maintains a deque based on array
// the free thread can steal task to execute from other running thread

- blockingqueue 
-- arrayListBlockingQueue 固定大小 （有界）
-- LinkedBlockingQueue顾名思义是用链表实现的队列，可以是有界的，也可以是无界的，但在Executors中默认使用无界的（无界）。 - newFixedThreadPool
-- SynchronousQueue 并不是队列 维护cache线程 任务直接交付 用于newCachedThreadPool （无）

### J.U.C
- reentrantlock（可重入独占锁） - lock - AQS队列阻塞队列
ReentrantLock 就是基于 AQS 实现的，ReentrantLock 内部有公平锁和非公平锁两种实现，差别就在于新来的线程是否比已经在同步队列中的等待线程更早获得锁。
互斥锁

- 读写锁

公平锁 严格先进先出/非公平 由底层os调度 影响吞吐量

- AQS 
CLH队列 先进先出 双向 自旋轮询前驱状态

AQS可以说是一个给予实现同步锁、同步器的一个框架，很多实现类都在它的的基础上构建的
在AQS中实现了对等待队列的默认实现，子类只要重写部分的代码即可实现

-- JUC同步器框架原理
--- 同步状态管理
--- CLH队列变体
--- 线程阻塞与唤醒 通过unsafe类
-- 独占线程的保存
--- AbstractOwnableSynchronizer是AQS的父类，提供基础的独占线程保存功能
-- CLH队列变体的实现
--- 同步队列 sync-queue
--- 条件等待队列 condition-queue
-- 独占模式/共享模式


- 读写锁/COWlist CopyOnWriteArrayList
- cyclicbarrier, countdownlatch, 
-countDownLatch
--可以实现计数器，需要等待其他任务结束后才能执行
-- 调用await()方法的线程会被挂起，等到为0继续执行
-- countdown() 将count减1



















========
JVM
========

### JVM 两种数据类型
基本类型：数值类型/boolean类型/returnAddress类型
和引用类型 类/数组/接口

### 运行时数据区: 
堆/方法区 pc寄存器（程序计数器）/jvm栈/native方法栈

- 永久代和方法区 jdk8区别
hotspot
1.6 方法区 -> 永久代
1.7 逐步移出永久代
1.8 元空间

- 四种引用类型 引用计数 可达性分析
- 分代收集原理 对象在新生代分配/触发minor gc 幸存区 存活年龄 空间分配担保 fullgc stop the world 
老年代占2/3
新生对象分配空间在edeneden-survivor（复制算法/年龄）
- 垃圾回收算法

- serial/serailOld； parnew/CMS； G1（标记整理/大对象直接进老年区/可指定stop the world时间

### 破坏双亲委派
线程上下文类加载器 osgi用网状的类加载结构

### 类加载过程
加载-链接-初始化/验证-运行时（JIT/编译/动态连接）

















=========
框架
=========
- Spirng AOP

静态AOP是指AspectJ实现的AOP，他是将切面代码直接编译到Java类文件中
Spring AOP采用的是动态代理，在运行期间对业务方法进行增强，所以不会生成新类，
动态代理
Spring AOP提供了对JDK动态代理的支持以及CGLib的支持 可以通过xml或注解的方式实现

如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP, 没有接口时只能通过cglib实现aop动态代理
动态代理 JDK（通过接口），cglib（通过继承）
动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。

- jdk动态代理
- cglib动态代理

- 常见注解
@RestController
@RestController=@ResponseBody+@Controller，该注解类下的所有函数都返回的是json类型数据，不再返回页面。
@Api swagger用覆盖路径值打tag description一直可用
@Configuration
Spring的@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。
@Autowired
@Component
@NestedConfigurationProperty，该注解会为basicProperties生成单独的一个属性组。如果不添加该注解，则不会生成单独的属性组，而是形成如下的一个属性节点：
@JsonUnwrapped @JsonUnwrapped: 作用在属性字段或方法上，用来将子JSON对象的属性添加到封闭的JSON对象。
@ConfigurationProperties适用与注入配置文件整个对应bean的全部属性，而@Value正如其名称一样，适合注入配置文件单个值
@TestPropertySource spring 在单测中envirionment注入优先

- spring controller重定向网页的方式
使用ModelAndView
使用SpringMVC
使用HttpServletResponse 












=========
中间件/分布式
========
### 分布式锁/
- 数据库唯一索引
- redis的setnx指令
- 分布式redis用redlock算法 从n个相互独立的redis实例获取锁
- zk 树形命名空间+节点类型zkid+监听器

### 分布式事务/

2PC
CAP
BASE
分布式协议
PAXOS 投票 三阶段

大数据组件


















==========
redis
==========
五种redis对象及其编码
- 字符串对象的编码可以是 int(利于数字） 、 raw 或者 embstr（利于短编码），底层数据结构是sds
- 列表对象编码可以是 ziplist（压缩列表） 或者 linkedlist（双端链表）
- 哈希对象的编码可以是 ziplist 或者 hashtable （哈希表）
- 集合对象的编码可以是 intset（整数集合） 或者 hashtable 
- 有序集合的编码可以是 ziplist 或者 skiplist（跳跃表） 

编码及对应数据结构设计
- sds 常数获取字符串长度
- 跳跃表 层 跨度
- 字典结构有两个哈希表
- ziplist 顺序型数据结构 连续内存 特殊编码

布隆过滤器
- 用于海量数据判存
- k个哈希函数映射到位向量的k个位置
- 缺点删除元素 -- countingBloomFilter
- funnel类将具体对象分解成原生字段值














==========
mysql
==========
### 隔离级别
-读未提交/允许脏读
-读已提交/允许不可重复读 -- 读操作 写时读操作加锁
-可重复读RR/允许幻读 -- 间隙锁
-可串行化

### innodb
- 支持事务
- 行锁
- 支持外键
- 支持非锁定读

- 实现mvcc乐观锁 提高并发 
MVCC会给每行元组加一些辅助字段，记录创建版本号和删除版本号。
而每一个事务在启动的时候，都有一个唯一的递增的版本号。每开启一个新事务，事务的版本号就会递增。

- 聚集索引
叶子节点存放整张表的行记录数据 利于主键排序查找和范围查找

- B+树
兄弟叶节点会维持索引

- redo log
物理日志，记录在数据页上的修改

### 共享锁排他锁
- 共享锁是可以加读锁，但不能加写锁
- 排他所不能再加所有锁

### innoDB是如何解决幻读的
在RR的隔离级别下，Innodb使用MVCC和next-key locks解决幻读，MVCC解决的是普通读（快照读）的幻读，next-key locks解决的是当前读情况下的幻读。
幻读和不可重复读的区别是，前者是一个范围，后者是本身

当前读指加锁的读，如所谓当前读，指的是加锁的select(S或者X), update, delete等语句。使用间隙锁
普通读指不会加锁的读，使用mvcc

### 索引
- 索引实现方式（hash 有序数组 搜索树 B+树）
在B+树中，我们将节点分为叶子结点和非叶子结点，非叶子结点上保存的是索引，而且一个节点可以保存多个索引；
数据全部存于叶子结点上,根据叶子结点的内容不同，innodb索引分为主键索引和非主键索引。
非主键索引也称为二级索引。主键索引的叶子结点中保存的数据为整行数据，而非主键索引叶子节点保存的是主键的值。（聚簇索引）

- 索引创建原则
1.选择唯一性索引
2.为经常需要排序、分组和联合操作的字段建立索引
3.为常作为查询条件的字段建立索引
4. 限制索引的数目
5. 尽量使用数据量少的索引
6. 最左前缀匹配原则，非常重要的原则。
mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配






=========
网络
=========
### HTTP
- http和https的区别
ssl/tls 密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法 

- http get和post区别

- 无状态协议与cookie

- 报文组成
请求行-头部字段-空行-请求数据

- 通用标头
Date Cache-control Connection等
- 实体标头
Content-Length Content-Language Content-Encoding
- 请求标头
Host Referer If-Modified-Since Accept
- 响应标头
Access-Control-Allow-Origin Keep-alive set-cookie X-Frame-Options(点击劫持）








